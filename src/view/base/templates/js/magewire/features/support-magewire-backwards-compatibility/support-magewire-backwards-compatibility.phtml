<?php

declare(strict_types=1);

use Magento\Framework\Escaper;
use Magento\Framework\View\Element\Template;
use Magewirephp\Magewire\ViewModel\Magewire as MagewireViewModel;

/** @var Escaper $escaper */
/** @var Template $block */
/** @var MagewireViewModel $magewireViewModel */

$magewireViewModel = $block->getData('view_model');
$magewireFragment = $magewireViewModel->utils()->fragment();

/** @internal Do not modify to ensure Magewire continues to function correctly. */
?>
<?php $script = $magewireFragment->make()->script()->start() ?>
<script>
    document.addEventListener('magewire:init', event => {
        const makeBackwardsCompatible = function(component) {
            return new Proxy(component, {
                get(target, prop, receiver) {
                    if (target.effects.bc && prop in target.effects.bc) {
                        const value = target.effects.bc[prop];

                        if (typeof value === 'string' && value.startsWith('path:')) {
                            return value.slice(5).split('.').reduce((obj, key) => obj?.[key], target);
                        }

                        return value;
                    }

                    return Reflect.get(target, prop, receiver);
                },

                has(target, prop) {
                    if (target.effects.bc && prop in target.effects.bc) {
                        return true;
                    }

                    return Reflect.has(target, prop);
                }
            });
        }

        <?php /* @deprecated 'component.initialized' has been replaced with 'component.init'. */ ?>
        Magewire.hook('component.init', ({ component, cleanup }) => {
            Magewire.trigger('component.initialized', makeBackwardsCompatible(component));
        });

        <?php /* @deprecated 'element.initialized' has been replaced with 'element.init'. */ ?>
        Magewire.hook('element.init', ({ el, component }) => {
            Magewire.trigger('element.initialized', el, makeBackwardsCompatible(component));
        });

        <?php /* @deprecated 'element.updating' has been replaced with 'morph.updating'. */ ?>
        Magewire.hook('morph.updating', ({ el, toEl, component }) => {
            Magewire.trigger('element.updating', el, toEl, makeBackwardsCompatible(component));
        });

        <?php /* @deprecated 'element.removed' has been replaced with 'morph.removed'. */ ?>
        Magewire.hook('morph.removed', ({ el, component }) => {
            Magewire.trigger('element.removed', el, makeBackwardsCompatible(component));
        });

        <?php /* @deprecated 'message.sent' has been replaced with 'commit'. */ ?>
        <?php /* @deprecated 'message.failed' has been replaced with 'commit' - fail(). */ ?>
        <?php /* @deprecated 'message.received' has been replaced with 'commit' - succeed(). */ ?>
        <?php /* @deprecated 'message.processed' has been replaced with 'commit' - succeed() - queueMicrotask. */ ?>
        Magewire.hook('commit', ({ component, commit, respond, succeed, fail }) => {
            component = makeBackwardsCompatible(component);

            const generateSignature = () => {
                return (Math.random() + 1).toString(36).substring(8)
            }

            let message = {
                component: component,
                response: {
                    effects: component.effects,
                    serverMemo: component.serverMemo
                },
                updateQueue: []
            }

            if (commit.calls.length !== 0) {
                commit.calls.forEach((value, method) => {
                    const signature = generateSignature();

                    message.updateQueue.push({
                        el: document.activeElement,
                        method: value.method,
                        payload: {
                            id: signature,
                            method: value.method,
                            params: value.params
                        },
                        rejectCallback: () => {},
                        resolveCallback: () => {},
                        signature: signature,
                        skipWatcher: false,
                        type: 'callMethod'
                    });
                });
            }

            if (Object.values(commit.updates).length !== 0) {
                Object.entries(commit.updates).forEach(([property, value]) => {
                    const signature = generateSignature();

                    message.updateQueue.push({
                        el: document.activeElement,
                        payload: {
                            id: signature,
                            name: property,
                            value: value
                        },
                        rejectCallback: () => {},
                        resolveCallback: () => {},
                        signature: signature,
                        skipWatcher: false,
                        type: 'syncInput'
                    })
                });
            }

            Magewire.trigger('message.sent', message, component);

            succeed(({ snapshot, effects }) => {
                Magewire.trigger('message.received', message, component)

                queueMicrotask(() => {
                    Magewire.trigger('message.processed', message, component)
                });
            });

            fail(() => {
                Magewire.trigger('message.processed', message, component)
            });
        });
    });
</script>
<?php $script->end() ?>
